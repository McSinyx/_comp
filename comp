#!/usr/bin/env python3
 
# comp - Curses Online Media Player
# Copyright (C) 2017 Nguyá»…n Gia Phong <vn.mcsinyx@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import curses
import json
import re
from argparse import ArgumentParser
from collections import deque
from configparser import ConfigParser
from curses.ascii import ctrl
from datetime import datetime
<<<<<<< HEAD
from gettext import bindtextdomain, gettext, textdomain
=======
from functools import reduce
from gettext import gettext as _, textdomain
>>>>>>> origin/testing
from itertools import cycle
from os import linesep, makedirs
from os.path import abspath, dirname, expanduser, isdir, isfile, join
from random import choice
from time import gmtime, strftime
from threading import Thread

from youtube_dl import YoutubeDL

from mpv import MPV, MpvFormat

# Init gettext
textdomain('comp')

# Global constants
SYSTEM_CONFIG = '/etc/comp/settings.ini'
USER_CONFIG = expanduser('~/.config/comp/settings.ini')
MPV_LOG = expanduser('~/.cache/comp/mpv.log')
MODES = ("play-current", "play-all", "play-selected", "repeat-current",
         "repeat-all", "repeat-selected", "shuffle-all", "shuffle-selected")
MODE_STR_LEN = max(len(_(mode)) for mode in MODES)
DURATION_COL_LEN = max(len(_("Duration")), 8)


def mpv_logger(loglevel, component, message):
    mpv_log = '{} [{}] {}: {}{}'.format(datetime.isoformat(datetime.now()),
                                        loglevel, component, message, linesep)
    with open(MPV_LOG, 'a') as f:
        f.write(mpv_log)


<<<<<<< HEAD
def setno(entries, keys):
    """Set all keys of each entry in entries to False."""
    for key in keys:
        for entry in entries:
            entry[key] = False


def getlink(entry):
    """Return an URL from the given entry."""
    try:
        return entry['webpage_url']
    except:
        with YoutubeDL({'quiet': True}) as ytdl:
            return ytdl.extract_info(
                entry['url'], download=False,
                ie_key=entry.get('ie_key')).get('webpage_url')

=======
def justified(s, width):
    """Return s left-justified of length width."""
    return s.ljust(width)[:width]


class Comp(object):
    """Meta object for drawing and playing.

    Attributes:
        entries (list): list of all tracks
        json_file (str): path to save JSON playlist
        mode (str): the mode to pick and play tracks
        mp (MPV): an mpv instance
        play_backward (bool): flag show if to play the previous track
        play_list (list): list of tracks according to mode
        played (list): list of previously played tracks
        playing (int): index of playing track in played
        playlist (iterator): iterator of tracks according to mode
        reading (bool): flag show if user input is being read
        search_res (iterator):  title-searched results
        scr (curses WindowObject): curses window object
        start (int): index of the first track to be printed on screen
        vid (str): flag show if video output is enabled
        y (int): the current y-coordinate
    """
    def __new__(cls, entries, json_file, mode, mpv_vo, mpv_vid, ytdlf):
        self = super(Comp, cls).__new__(cls)
        self.play_backward, self.reading = False, False
        self.playing, self.start, self.y = -1, 0, 1
        self.json_file, self.mode, self.vid = json_file, mode, mpv_vid
        self.entries, self.played = entries, []
        self.playlist, self.search_res = iter(()), deque()
        self.mp = MPV(input_default_bindings=True, input_vo_keyboard=True,
                      log_handler=mpv_logger, ytdl=True, ytdl_format=ytdlf)
        self.scr = curses.initscr()
        return self

    def update_status(self, message='', msgattr=curses.A_NORMAL):
        """Update the status lines at the bottom of the screen."""
        def adds(s, a, y=curses.LINES-2, x=0):
            if not self.reading: self.scr.addstr(y, x, s, a)

        right = ' {} {}{} '.format(_(self.mode), ' ' if self.mp.mute else 'A',
                                   ' ' if self.vid == 'no' else 'V')
        adds(right.rjust(curses.COLS), curses.color_pair(12))
        try:
            left = ' {} / {} {} '.format(
                self.mp.osd.time_pos, self.mp.osd.duration,
                '|' if self.mp.pause else '>')
            title_len = curses.COLS - len(left + right)
            center = justified(self.mp.media_title, title_len)
        except:
            pass
        else:
            adds(left, curses.color_pair(12))
            adds(center, curses.color_pair(12) | curses.A_BOLD, x=len(left))
        if message:
            adds(justified(message, curses.COLS - 1), msgattr,
                 y=curses.LINES-1, x=0)
        self.scr.refresh()

    def getlink(self, entry):
        """Return an URL from the given entry."""
        if 'webpage_url' not in entry:
            with YoutubeDL({'quiet': True}) as ytdl:
                entry.update(ytdl.extract_info(entry['url'], download=False,
                                               ie_key=entry.get('ie_key')))
        self.uniform(entry)
        return entry['webpage_url']

    def setno(self, *keys):
        """Set all keys of each entry in entries to False."""
        for entry in self.entries:
            for key in keys:
                entry[key] = False

    def play(self, force=False):
        """Play the next track."""
        def mpv_play(entry, force):
            self.setno('playing')
            entry['playing'] = True
            self.mp.vid = self.vid
            try:
                self.mp.play(self.getlink(entry))
            except:
                entry['error'] = True
            self.print(entry)
            if force: self.mp.pause = False
            self.mp.wait_for_playback()
            self.play()
            entry['playing'] = False
            self.print(entry)

        if self.play_backward and -self.playing < len(self.played):
            self.playing -= 1
            t = self.played[self.playing], force
        elif self.playing < -1:
            self.playing += 1
            t = self.played[self.playing], force
        else:
            try:
                self.played.append(next(self.playlist))
            except StopIteration:
                return
            else:
                t = self.played[-1], force

        self.play_backward = False
        play_thread = Thread(target=mpv_play, args=t, daemon=True)
        play_thread.start()
>>>>>>> origin/testing

    def uniform(self, entry):
        """Standardize data format."""
        for i in 'error', 'playing', 'selected': entry.setdefault(i, False)
        entry.setdefault('ie_key', entry.get('extractor'))
        entry.setdefault('duration', 0)
        if 'title' not in entry:    # or 'webpage_url' not in entry:
            with YoutubeDL({'quiet': True}) as ytdl:
                entry.update(ytdl.extract_info(entry['url'], download=False,
                                               ie_key=entry.get('ie_key')))
        for i in entry.copy():
            if i not in ('duration', 'error', 'playing', 'selected',
                         'ie_key', 'title', 'url', 'webpage_url'):
                entry.pop(i)

    def _writeln(self, y, title, duration, attr):
        title_len = curses.COLS-DURATION_COL_LEN-3
        title = justified(title, title_len)
        duration = duration.ljust(DURATION_COL_LEN)
        self.scr.addstr(y, 0, ' {} {} '.format(title, duration), attr)
        self.scr.refresh()

    def print(self, entry=None, y=None):
        """Print the entry in the line y."""
        if entry is y is None:
            entry = self.current()
            y = self.idx() - self.start + 1
        elif entry is None:
            entry = self.entries[self.start + y - 1]
        elif y is None:
            y = self.idx(entry) - self.start + 1
        if y < 1 or y > curses.LINES - 3: return

        self.uniform(entry)
        c = {'error': 1, 'playing': 3, 'selected': 5}
        color = ((8 if entry is self.current() else 0)
            | reduce(int.__xor__, (c.get(i, 0) for i in entry if entry[i])))
        duration = strftime('%H:%M:%S', gmtime(entry['duration']))
        if color:
            self._writeln(y, entry['title'], duration,
                          curses.color_pair(color) | curses.A_BOLD)
        else:
            self._writeln(y, entry['title'], duration,
                          curses.A_NORMAL)

    def redraw(self):
        """Redraw the whole screen."""
        self._writeln(0, _("Title"), _("Duration"),
                      curses.color_pair(10) | curses.A_BOLD)
        for i, entry in enumerate(self.entries[self.start:][:curses.LINES-3]):
            self.print(entry, i + 1)
        self.scr.clrtobot()
        self.update_status()

    def __init__(self, json_file, entries, mode, mpv_vo, mpv_vid, ytdlf):
        if mpv_vo is not None: self.mp['vo'] = mpv_vo
        def property_handler(name, val): self.update_status()
        self.mp.observe_property('mute', property_handler)
        self.mp.observe_property('pause', property_handler)
        self.mp.observe_property('time-pos', property_handler,
                                 force_fmt=MpvFormat.INT64)
        curses.noecho()
        curses.cbreak()
        self.scr.keypad(True)
        curses.curs_set(False)
        curses.start_color()
        curses.use_default_colors()
        for i in range(1, 8): curses.init_pair(i, i, -1)
        curses.init_pair(8, -1, 7)
        for i in range(1, 7): curses.init_pair(i + 8, -1, i)
        self.redraw()

    def __enter__(self): return self

    def idx(self, entry=None):
        """Return the index of the current entry."""
        if entry is None:
            return self.start + self.y - 1
        return self.entries.index(entry)

    def current(self):
        """Return the current entry."""
        try:
            return self.entries[self.idx()]
        except:
            return {}

    def update_play_list(self, pick):
        """Update the list of entries to be played."""
        if pick == 'current':
            self.play_list = [self.current()]
        elif pick == 'all':
            self.play_list = deque(self.entries)
            self.play_list.rotate(-self.idx())
        else:
            self.play_list = [i for i in self.entries if i.get('selected')]

    def update_playlist(self):
        """Update the playlist to be used by play function."""
        action, pick = self.mode.split('-')
        self.update_play_list(pick)
        if action == 'play':
            self.playlist = iter(self.play_list)
        elif action == 'repeat':
            self.playlist = cycle(self.play_list)
        else:
            self.playlist = iter(lambda: choice(self.play_list), None)
        if self.playing < -1: self.played = self.played[:self.playing+1]

    def gets(self, prompt):
        """Print the prompt string at the bottom of the screen then read
        from standard input.
        """
        self.scr.addstr(curses.LINES - 1, 0,
                        justified(prompt, curses.COLS - 1))
        self.reading = True
        curses.curs_set(True)
        curses.echo()
        b = self.scr.getstr(curses.LINES - 1, len(prompt))
        self.reading = False
        curses.curs_set(False)
        curses.noecho()
        return b.decode()

    def seek(self, amount, reference='relative', precision='default-precise'):
        """Wrap mp.seek with a try clause to avoid crash when nothing is
        being played.
        """
        try:
            self.mp.seek(amount, reference, precision)
        except:
            pass

    def next(self, force=False, backward=False):
        comp.play_backward = backward
        if self.mp.idle_active:
            self.play(force)
        else:
            self.seek(100, 'absolute-percent')
            if force: self.mp.pause = False

    def download(self):
        with YoutubeDL({'quiet': True}) as ytdl:
            ytdl.download([self.getlink(i) for i in self.play_list])

    def move(self, delta):
        """Move to the relatively next delta entry."""
        if not (self.entries and delta): return
        start, prev_entry = self.start, self.current()
        maxy = min(len(self.entries), curses.LINES - 3)

        if self.idx() + delta <= 0:
            self.start, self.y = 0, 1
        elif self.idx() + delta >= len(self.entries):
            self.start, self.y = len(self.entries) - maxy, maxy
        elif self.y + delta < 1:
            self.start += self.y + delta - 1
            self.y = 1
        elif self.y + delta > curses.LINES - 3:
            self.start += self.y + delta - maxy
            self.y = maxy
        else:
            self.y += delta

        if self.start == start:
            self.print(prev_entry)
            self.print()
        else:
            self.redraw()

    def search(self, backward=False):
        """Prompt then search for a pattern."""
        p = re.compile(self.gets('/'), re.IGNORECASE)
        entries = deque(self.entries)
        entries.rotate(-self.idx())
        self.search_res = deque(filter(
            lambda entry: p.search(entry['title']) is not None, entries))
        if backward: self.search_res.reverse()
        if self.search_res:
            self.move(self.idx(self.search_res[0]) - self.idx())
        else:
            self.update_status(_("Pattern not found"), curses.color_pair(1))

    def next_search(self, backward=False):
        """Repeat previous search."""
        if self.search_res:
            self.search_res.rotate(1 if backward else -1)
            self.move(self.idx(self.search_res[0]) - self.idx())
        else:
            self.update_status(_("Pattern not found"), curses.color_pair(1))

    def resize(self):
        curses.update_lines_cols()
        l = curses.LINES - 3
        if curses.COLS < MODE_STR_LEN + 42 or l < 1:
            sizeerr = _("Current size: {}x{}. Minimum size: {}x4.").format(
                curses.COLS, curses.LINES, MODE_STR_LEN + 42)
            self.scr.addstr(0, 0, sizeerr[:curses.LINES*curses.COLS-1])
        elif self.y > l:
            self.start += self.y - l
            self.y = l
            self.redraw()
        elif 0 < self.start > len(self.entries) - l:
            idx, self.start = self.idx(), min(0, len(entries) - l)
            self.y = idx - self.start + 1
            if self.y > l:
                self.start += self.y - l
                self.y = l
            self.redraw()
        else:
            self.redraw()

<<<<<<< HEAD
def secpair2hhmmss(pos, duration):
    """Quick hack to convert a pair of seconds to HHMMSS / HHMMSS
    string as MPV.get_property_osd_string isn't available.
    """
    if pos is None: return ''
    postime, durationtime = gmtime(pos), gmtime(duration)
    # Let's hope media durations are shorter than a day
    timestr = '%M:%S' if duration < 3600 else '%H:%M:%S'
    return '{} / {}'.format(strftime(timestr, postime),
                            strftime(timestr, durationtime))


def update_status(stdscr, mp, message='', msgattr=curses.A_NORMAL):
    left = ' ' + secpair2hhmmss(mp._get_property('time-pos', int),
                                mp._get_property('duration', int))
    right = ' {} {}{} '.format(_(mode),
                               ' ' if mp._get_property('mute', bool) else 'A',
                               ' ' if mp._get_property('vid') == 'no' else 'V')
    if left != ' ':
        left += ' | ' if mp._get_property('pause', bool) else ' > '
        stdscr.addstr(curses.LINES - 2, 0, left, curses.color_pair(14))
        title_len = curses.COLS - len(left + right)
        entry = [i for i in entries if i['playing']][0]
        center = entry.setdefault('title', mp._get_property('media-title')).ljust(title_len)[:title_len]
        stdscr.addstr(curses.LINES - 2, len(left), center,
                      curses.color_pair(14) | curses.A_BOLD)
        stdscr.addstr(curses.LINES - 2, len(left + center), right,
                      curses.color_pair(14))
    else:
        stdscr.addstr(curses.LINES - 2, 0, right.rjust(curses.COLS),
                      curses.color_pair(14))
    stdscr.move(curses.LINES - 1, 0)
    stdscr.clrtoeol()
    stdscr.addstr(curses.LINES - 1, 0, message, msgattr)
    stdscr.refresh()


def reattr(stdscr, y, entry):
    invert = 8 if entry.setdefault('current', False) else 0
    if entry.setdefault('error', False):
        stdscr.chgat(y, 0, curses.color_pair(1 + invert) | curses.A_BOLD)
    elif entry.setdefault('playing', False):
        stdscr.chgat(y, 0, curses.color_pair(3 + invert) | curses.A_BOLD)
    elif entry.setdefault('selected', False):
        stdscr.chgat(y, 0, curses.color_pair(5 + invert) | curses.A_BOLD)
    elif invert:
        stdscr.chgat(y, 0, curses.color_pair(12) | curses.A_BOLD)
    else:
        stdscr.chgat(y, 0, curses.color_pair(0))


def reprint(stdscr, entries2print):
    stdscr.clear()
    stdscr.addstr(0, 1, _('Title'))
    sitenamelen = max(max(len(entry['ie_key']) for entry in entries), 6)
    stdscr.addstr(0, curses.COLS - sitenamelen - 1, _('Source'))
    stdscr.chgat(0, 0, curses.color_pair(10) | curses.A_BOLD)
    for i, entry in enumerate(entries2print):
        y = i + 1
        stdscr.addstr(y, 0, entry['ie_key'].rjust(curses.COLS - 1))
        stdscr.addstr(y, 1, entry.get('title', '')[:curses.COLS-sitenamelen-3])
        reattr(stdscr, y, entry)
    update_status(stdscr, mp)


def initprint(stdscr, entries):
    """Print initial content."""
    global start, y
    start, y = 0, 1
    if not entries:
        return
    setno(entries, ['current', 'error', 'playing', 'selected'])
    entries[0]['current'] = True
    reprint(stdscr, entries[:curses.LINES-3])


def move(stdscr, entries, y, delta):
    global start
    if start + y + delta < 1:
        if start + y == 1:
            return 1
        setno(entries, ['current'])
        start = 0
        entries[0]['current'] = True
        reprint(stdscr, entries[:curses.LINES-3])
        return 1
    elif start + y + delta > len(entries):
        start = max(len(entries) - curses.LINES + 3, 0)
        y = min(curses.LINES - 3, len(entries))
        setno(entries, ['current'])
        entries[-1]['current'] = True
        reprint(stdscr, entries[-curses.LINES+3:])
        return y

    if y + delta < 1:
        start += y + delta - 1
        y = 1
        setno(entries, ['current'])
        entries[start]['current'] = True
        reprint(stdscr, entries[start : start+curses.LINES-3])
    elif y + delta > curses.LINES - 3:
        start += y + delta - curses.LINES + 3
        y = curses.LINES - 3
        setno(entries, ['current'])
        entries[start + curses.LINES - 4]['current'] = True
        reprint(stdscr, entries[start : start+curses.LINES-3])
    else:
        entries[start + y - 1]['current'] = False
        reattr(stdscr, y, entries[start + y - 1])
        y = y + delta
        entries[start + y - 1]['current'] = True
        reattr(stdscr, y, entries[start + y - 1])
        stdscr.refresh()
    return y
=======
    def __exit__(self, exc_type, exc_value, traceback):
        curses.nocbreak()
        self.scr.keypad(False)
        curses.echo()
        curses.endwin()
        self.mp.quit()
>>>>>>> origin/testing


def gets(stdscr, prompt):
    stdscr.addstr(curses.LINES - 1, 0, prompt)
    curses.curs_set(True)
    curses.echo()
    s = stdscr.getstr(curses.LINES - 1, len(prompt)).decode()
    curses.curs_set(False)
    curses.noecho()
    return s


parser = ArgumentParser(description=_("Curses Online Media Player"))
parser.add_argument('-c', '--config', required=False,
                    help=_("location of the configuration file; either the\
                            path to the config or its containing directory"))
parser.add_argument('--vid', choices=('ID', 'auto', 'no'), required=False,
                    help=_("initial video channel. auto selects the default,\
                            no disables video"))
parser.add_argument('--vo', required=False, metavar='DRIVER',
                    help=_("specify the video output backend to be used. See\
                            VIDEO OUTPUT DRIVERS in mpv(1) man page for\
                            details and descriptions of available drivers"))
parser.add_argument('-f', '--format', required=False, metavar='YTDL_FORMAT',
                    help=_("video format/quality to be passed to youtube-dl"))
parser.add_argument('-u', '--online-playlist', required=False, metavar='URL',
                    help=_("URL to an playlist on Youtube"))
parser.add_argument('-j', '--json', required=False, metavar='JSON_PLAYLIST',
                    help=_("path to playlist in JSON format. If\
                            --online-playlist is already specified, this will\
                            be used as the default file to save the playlist"))
args = parser.parse_args()

config = ConfigParser()
<<<<<<< HEAD
config.read(USER_CONFIG if isfile(USER_CONFIG) else SYSTEM_CONFIG)
mode = config.get('comp', 'play-mode', fallback='play-current')
video = config.get('mpv', 'video', fallback='auto')
video_output = config.get('mpv', 'video-output', fallback=None)
ytdl_opts = {'format': config.get('youtube-dl', 'format', fallback='best')}

if args.json_playlist:
    json_file = args.json_playlist
    with open(json_file) as f:
        entries = json.load(f)
elif args.youtube_playlist:
    with YoutubeDL({'extract_flat': True, 'quiet': True}) as ytdl:
        info = ytdl.extract_info(args.youtube_playlist, download=False)
        entries = info.get('entries', {})
    json_file = ''
=======
if args.config is not None:
    if isfile(args.config):
        config_file = args.config
    else:   #isdir(args.config_location):
        config_file = join(args.config, 'settings.ini')
elif isfile(USER_CONFIG):
    config_file = USER_CONFIG
else:
    config_file = SYSTEM_CONFIG
config.read(config_file)

if args.json is not None:
    json_file = args.json
>>>>>>> origin/testing
else:
    json_file = ''

<<<<<<< HEAD
# Init curses screen
stdscr = curses.initscr()
curses.noecho()
curses.cbreak()
stdscr.keypad(True)
curses.curs_set(False)
curses.start_color()
curses.use_default_colors()
curses.init_pair(1, 1, -1)
curses.init_pair(2, 2, -1)
curses.init_pair(3, 3, -1)
curses.init_pair(4, 4, -1)
curses.init_pair(5, 5, -1)
curses.init_pair(6, 6, -1)
curses.init_pair(7, 7, -1)
curses.init_pair(8, -1, 7)
curses.init_pair(9, -1, 1)
curses.init_pair(10, -1, 2)
curses.init_pair(11, -1, 3)
curses.init_pair(12, -1, 4)
curses.init_pair(13, -1, 5)
curses.init_pair(14, -1, 6)

# Init mpv
makedirs(expanduser(dirname(MPV_LOG)), exist_ok=True)
mp = MPV(input_default_bindings=True, input_vo_keyboard=True,
         log_handler=mpv_logger, ytdl=True, ytdl_format=ytdl_opts['format'])
if video_output: mp['vo'] = video_output
mp._set_property('vid', video)
mp.observe_property('mute', lambda foo: update_status(stdscr, mp))
mp.observe_property('pause', lambda foo: update_status(stdscr, mp))
mp.observe_property('time-pos', lambda foo: update_status(stdscr, mp))
mp.observe_property('vid', lambda foo: update_status(stdscr, mp))

initprint(stdscr, entries)
c = stdscr.getch()
while c != 113:     # letter q
    if c == 10:     # curses.KEY_ENTER doesn't work
        if not entries: continue
        mp._set_property('pause', False, bool)
        play_thread = Thread(target=play, daemon=True)
        play_thread.start()
    elif c == 32:   # space
        if not entries: continue
        i = start + y - 1
        entries[i]['selected'] = not entries[i].setdefault('selected', False)
        y = move(stdscr, entries, y, 1)
    elif c == 65:   # letter A
        mp._toggle_property('mute')
    elif c == 77:   # letter M
        mode = MODES[(MODES.index(mode) - 1) % 8]
        update_status(stdscr, mp)
    elif c == 79:   # letter O
        json_file = gets(stdscr, _("Open JSON playlist: "))
        try:
            with open(json_file) as f:
                entries = json.load(f)
        except:
            update_status(stdscr, mp)
        else:
            initprint(stdscr, entries)
    elif c == 85:   # letter U
        with YoutubeDL({'extract_flat': True, 'quiet': True}) as ytdl:
            try:
                info = ytdl.extract_info(gets(
                    stdscr, _("Open online playlist: ")), download=False)
            except:
                reprint(stdscr, entries[start : start+curses.LINES-3])
            else:
                entries = info.get('entries', {})
                initprint(stdscr, entries)
    elif c == 86:   # letter V
        mp._set_property('vid',
                         'auto' if mp._get_property('vid') == 'no' else 'no')
    elif c == 87:   # letter W
        if not entries: continue
        s = gets(stdscr, _('Save playlist to [{}]: ').format(json_file))
        if s: json_file = s
        try:
            makedirs(dirname(abspath(json_file)), exist_ok=True)
            with open(json_file, 'w') as f:
                json.dump(entries, f)
        except:
            update_status(stdscr, mp,
                          _("'{}': Can't open file for writing").format(json_file),
                          curses.color_pair(1))
        else:
            update_status(stdscr, mp,
                          _("'{}' written").format(json_file))
    elif c == 97:   # letter a
        url = gets(stdscr, _("Add URL: "))
        with YoutubeDL({'quiet': True, 'default_search': 'ytsearch'}) as ytdl:
            try:
                entry = ytdl.extract_info(url, download=False)
            except:
                update_status(stdscr, mp)
            else:
                #entry.pop('format')
                entry = entry.get('entries', [entry])
                entry = entry[0]
                entry['ie_key'] = entry['extractor']
                entries.insert(start + y - 1, entry)
                entries[start + y]['current'] = False
                entries[start + y - 1]['current'] = True
                reprint(stdscr, entries[start : start+curses.LINES-3])
    elif c == 100:  # letter d
        if not entries: continue
        i = start + y - 1
        if i + 1 < len(entries):
            entries.pop(i)
            entries[i]['current'] = True
        elif len(entries) > 1:
            entries.pop(i)
            entries[i - 1]['current'] = True
        else:
            entries = []
        reprint(stdscr, entries[start : start+curses.LINES-3])
    elif c == 109:  # letter m
        mode = MODES[(MODES.index(mode) + 1) % 8]
        update_status(stdscr, mp)
    elif c == 112:  # letter p
        mp._toggle_property('pause')
    elif c == 119:  # letter w
        if not entries: continue
        with YoutubeDL({'format': ytdlf}) as ytdl:
            ytdl.download([getlink(entry) for entry in choose_from(mode)])
    elif c in (curses.KEY_UP, 107):     # up arrow or letter k
        if not entries: continue
        y = move(stdscr, entries, y, -1)
    elif c in (curses.KEY_DOWN, 106):   # down arrow or letter j
        if not entries: continue
        y = move(stdscr, entries, y, 1)
    elif c in (curses.KEY_LEFT, 104):   # left arrow or letter h
        if mp._get_property('duration', int):
            mp.seek(-2.5)
    elif c in (curses.KEY_RIGHT, 108):  # right arrow or letter l
        if mp._get_property('duration', int):
            mp.seek(2.5)
    elif c == curses.KEY_HOME:  # home
        if not entries: continue
        y = move(stdscr, entries, y, -len(entries))
    elif c == curses.KEY_END:   # end
        if not entries: continue
        y = move(stdscr, entries, y, len(entries))
    elif c == curses.KEY_NPAGE:     # page down
        if not entries: continue
        y = move(stdscr, entries, y, curses.LINES - 4)
    elif c == curses.KEY_PPAGE:     # page up
        if not entries: continue
        y = move(stdscr, entries, y, 4 - curses.LINES)
    elif c == curses.KEY_F5:    # F5
        reprint(stdscr, entries[start : start+curses.LINES-3])
    elif c == curses.KEY_RESIZE:
        curses.update_lines_cols()
        if curses.COLS < MODE_STR_LEN + 42 or curses.LINES < 4:
            stdscr.clear()
            sizeerr = _('Current size: {}x{}. Minimum size: {}x4.').format(
                curses.COLS, curses.LINES, MODE_STR_LEN + 42)
            stdscr.addstr(0, 0, sizeerr[:curses.LINES*curses.COLS])
        else:
            start += y - 1
            y = 1
            reprint(stdscr, entries[start : start+curses.LINES-3])
    c = stdscr.getch()
=======
if args.online_playlist is not None:
    with YoutubeDL({'extract_flat': 'in_playlist', 'quiet': True}) as ytdl:
        info = ytdl.extract_info(args.online_playlist, download=False)
        entries = info.get('entries', [info])
else:
    try:
        with open(json_file) as f: entries = json.load(f)
    except FileNotFoundError:
        entries = []
>>>>>>> origin/testing

if args.vid is not None:
    vid = args.vid
else:
    vid = config.get('mpv', 'video', fallback='auto')

if args.vo is not None:
    vo = args.vo
else:
    vo = config.get('mpv', 'video-output', fallback=None)

mode = config.get('comp', 'play-mode', fallback='play-current')

if args.format is not None:
    ytdlf = args.format
else:
    ytdlf = config.get('youtube-dl', 'format', fallback='best')

makedirs(dirname(MPV_LOG), exist_ok=True)

with Comp(entries, json_file, mode, vo, vid, ytdlf) as comp:
    c = comp.scr.getch()
    while c != 113:     # letter q
        if c == 10:     # curses.KEY_ENTER doesn't work
            comp.update_playlist()
            comp.next(force=True)
        elif c == 32:   # space
            comp.current()['selected'] = not comp.current().get('selected')
            comp.move(1)
        elif c == 47:   # /
            comp.search()
        elif c == 60:   # <
            try:
                if comp.mp._get_property('time-pos', float) < 1:
                    comp.next(backward=True)
                else:
                    comp.seek(0, 'absolute')
            except:
                pass
        elif c == 62:   # >
            comp.next()
        elif c == 63:   # ?
            comp.search(backward=True)
        elif c == 65:   # letter A
            comp.mp.mute ^= True    # hack to toggle bool value
        elif c == 77:   # letter M
            comp.mode = MODES[(MODES.index(comp.mode) - 1) % 8]
            comp.update_status()
        elif c == 78:  # letter N
            comp.next_search(backward=True)
        elif c == 85:   # letter U
            with YoutubeDL({'extract_flat': True, 'quiet': True}) as ytdl:
                try:
                    info = ytdl.extract_info(
                        comp.gets(_("Open online playlist: ")), download=False)
                except:
                    comp.redraw()
                else:
                    comp.entries = info.get('entries', [info])
                    comp.start, comp.y = 0, 1
                    comp.redraw()
        elif c == 86:   # letter V
            comp.vid = 'auto' if comp.vid == 'no' else 'no'
            comp.mp.vid = comp.vid
            comp.update_status()
        elif c == 87:   # letter W
            s = comp.gets(_("Save playlist to [{}]: ").format(comp.json_file))
            if s: comp.json_file = s
            try:
                makedirs(dirname(abspath(comp.json_file)), exist_ok=True)
                with open(comp.json_file, 'w') as f: json.dump(comp.entries, f)
            except:
                errmsg = _("'{}': Can't open file for writing").format(
                    comp.json_file)
                comp.update_status(errmsg, curses.color_pair(1))
            else:
                comp.update_status(_("'{}' written").format(comp.json_file))
        elif c == 100:  # letter d
            i = comp.idx()
            if i + 1 < len(entries):
                comp.entries.pop(i)
            elif len(entries) > 1:
                comp.entries.pop(i)
            else:
                comp.entries = []
            comp.redraw()
        elif c == 112:  # letter p
            comp.mp.pause ^= True
        elif c == 109:  # letter m
            comp.mode = MODES[(MODES.index(comp.mode) + 1) % 8]
            comp.update_status()
        elif c == 110:  # letter n
            comp.next_search()
        elif c == 119:  # letter w
            comp.update_play_list(comp.mode.split('-')[1])
            play_thread = Thread(target=comp.download, daemon=True)
            play_thread.start()
        elif c in (curses.KEY_UP, 107):     # up arrow or letter k
            comp.move(-1)
        elif c in (curses.KEY_DOWN, 106):   # down arrow or letter j
            comp.move(1)
        elif c in (curses.KEY_LEFT, 104):   # left arrow or letter h
            comp.seek(-5, precision='exact')
        elif c in (curses.KEY_RIGHT, 108):  # right arrow or letter l
            comp.seek(5, precision='exact')
        elif c == curses.KEY_HOME:  # home
            comp.move(-len(comp.entries))
        elif c == curses.KEY_END:   # end
            comp.move(len(comp.entries))
        elif c == curses.KEY_NPAGE:     # page down
            comp.move(curses.LINES - 4)
        elif c == curses.KEY_PPAGE:     # page up
            comp.move(4 - curses.LINES)
        elif c in (curses.KEY_F5, curses.KEY_RESIZE):
            comp.resize()
        c = comp.scr.getch()
